\chapter{Abordagens Evolucionárias para a TMAP}

No último capítulo, foram apresentados os algoritmos evolucionários usados nesta 
pesquisa. No entanto, algumas lacunas ficaram abertas: não foram apresentadas 
formas de gerar indivíduos, isto é, soluções para a \ac{tmap}, de forma 
arbitrária para a primeira população, além de como aplicar 
recombinação e mutação neles. Dessa forma, neste capítulo, serão propostos 
operadores para construção de indivíduos, bem como para mutação e recombinação.

\section{Criação de Indivíduos}

Assim como em \citep{Pippin:2013:PBT:2480362.2480378} e \citep{4630897}, as 
soluções resultantes das abordagens evolucionárias aqui propostas são baseadas 
em particionamento (vide \secref{sec:classifytmap}). Dessa forma, a criação de 
indivíduos foi dividida em três etapas. A primeira é o cálculo de $r$ centros, 
onde $r$ é o número de agentes, ao redor dos quais os agentes deverão patrulhar. 
A segunda tarefa é a escolha dos nós, ao redor do centro, que comporão cada 
partição. Por fim, falta o cálculo de um ciclo, para cada partição, que passe 
por todos os seus vértices. Essas tarefas foram chamadas respectivamente de 
\textit{centering}, \textit{partitioning} e \textit{path building}.

Nas subseções seguintes, cada uma dessas três tarefas serão tratadas 
separadamente, mas é importante notar que uma tarefa depende da resposta dada 
pela sua antecessora. Serão apresentadas mais de um operador que executa cada 
tarefa, assim ao montar um algoritmo evolucionário, o leitor pode construir 
seus indivíduos com qualquer combinação deles.

\subsection{\textit{Centering}}

A primeira forma proposta para se calcular os centros é chamada de 
\textit{Random Centering}, e consiste em simplesmente escolher nós aleatórios do 
grafo para ser os centros. Veja o Pseudocódigo~\ref{centering_random} abaixo.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Random Centering}}          % give the algorithm a caption
	\label{centering_random}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{RANDOM-CENTERING}{$V, r$}
		\newline
		\Comment{$V$ é o conjunto de vértices do grafo e $r$ é o número de agentes}
		\State $Vertices \gets $ Cópia($V$)
		\State $Centros \gets \{\}$
		\For{$1 ...\ r$}
			\State $Centros \gets Centros\ \cup$ \{Seleciona-Aleatoriamente-Remove($Vertices$)\}
		\EndFor
		\State \textbf{Retorne} $Centros$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Uma outra forma de escolher os centros é tentar encontrar os vértices do grafo 
que estejam mais distantes uns dos outros. O objetivo neste operador é iniciar 
indivíduos de forma um pouco mais inteligente, para aumentar as chances de 
serem indivíduos com alta aptidão, mas sem apagar completamente o lado aleatório 
indicado às inicializações de indivíduos nos algoritmos evolucionários. 
\citep{Luke2013Metaheuristics} alerta os seus leitores para os perigos de 
utilizar heurísticas que aparentam gerar melhores indivíduos, mas que podem 
estar, inadvertidamente, condenando os algoritmos evolucionários a ficarem 
"presos"\ em mínimos locais.

O pseudocódigo~\ref{centering_maximum} mostra como seria a implementação deste 
operador.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Approximated Maximum Distance Centering}}          % give the algorithm a caption
	\label{centering_maximum}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{APPROXIMATED-MAXIMUM-DISTANCE-CENTERING}{$G(V,E), r$}
		\newline
		\Comment{$G(V,E)$ é o grafo e $r$ é o número de agentes}
		\State $Vertices \gets $ Cópia($V$)
		\State $Centros \gets $ RANDOM-CENTERING($V$, $r$)
		\State $d \gets $ Soma-Distancias($G(V,E)$, $centros$) \Comment{Soma as distâncias entre os vértices}
		\Repeat
			\State $centro \gets $ escolhe um vértice aleatório de $centros$
			\For{$V_{i} \in $ Sucessores($G(V,E)$, $centro$), onde $V_{i} \notin Centros$}
				\State Substitui($Centros$, $centro$, $V_{i}$) \Comment{Substitui $centro$ por $V_{i}$ em $Centros$}
				\State $d^{\prime} \gets $ Soma-Distancias($G(V,E)$, $centros$)
				\If{$d > d^{\prime}$}
					\State Substitui($Centros$, $V_{i}$, $centro$)
				\EndIf
			\EndFor
		\Until{não tenhamos mais tempo}
		\State \textbf{Retorne} $Centros$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa selecionando $r$ centros aleatoriamente, onde $r$ é o número 
de agentes. Depois, ele calcula o somatório das distâncias entre todos os $r$ 
vértices. Então, a cada iteração, um centro é escolhido aleatoriamente. Todos 
os sucessores do centro escolhido são testados no lugar do centro, se essa troca 
fizer com que os somatórios das distâncias entre os centros aumente, o sucessor 
fica no lugar do centro.

\subsection{\textit{Partitioning}}

Seguindo a mesma ideia de ter uma opção completamente aleatória de criar os 
indivíduos, uma das formas propostas para calcular as partições é chamada de 
\textit{Random Partitioning}. O pseudocódigo~\ref{partitioning_random} 
exemplifica como isso pode ser implementado.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Random Partitioning}}          % give the algorithm a caption
	\label{partitioning_random}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{RANDOM-PARTITIONING}{$centros, G(V,E)$}
		\newline
		\Comment{$G$ é o o grafo e $centros$ é a lista de centros calculados anteriormente}
		\State $Particoes \gets $ \{\}
		\State $verticesAdicionados \gets $ \{\}
		\Repeat
			\State $centro \gets $ escolhe aleatoriamente um elemento de $centros$
			\State $candidato \gets $ Seleciona-Aleatoriamente($V$) \Comment{$candidato \notin centros$}
			\State $caminho \gets $ Menor-Caminho($G$, $centro$, $candidato$)
			\State $Particoes(centro) \gets Particoes(centro)\ \cup caminho$
			\State $verticesAdicionados \gets verticesAdicionados\ \cup caminho$
		\Until{$|verticesAdicionados| = |V|$}
		\State \textbf{Retorne} $Particoes$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O \textit{Random Partitioning} consiste em criar uma lista de partições para 
cada centro. A cada iteração do \textit{loop} principal, um centro é escolhido 
aleatoriamente. Então, um outro vértice do grafo também é escolhido de forma 
aleatória (desde que não seja um centro). Depois, é adicionado à partição 
daquele centro escolhido todo o menor caminho entre ele mesmo e o vértice 
escolhido. O menor caminho inteiro é adicionado para que as partições estejam 
conectadas, isto é, para que seja possível traçar um caminho, dentro do grafo 
$G$, entre seus vértices. Finalmente, o \textit{Random Partitioning} para quando 
todos os nós do grafo estiverem em alguma partição.

Como o outro operador de particionamento do grafo é mais complexo, primeiro 
será apresentado o pseudocódigo ao leitor, e então será feita uma discussão 
de suas propriedades. Observe o pseudocódigo~\ref{partitioning_fungal}.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Heuristic Graph Partitioning}}          % give the algorithm a caption
	\label{partitioning_fungal}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                    % enter the algorithmic environment
		\Procedure{GRAPH-PARTITIONING}{$centros, G(V,E)$}
		\newline
		\Comment{$G$ é o o grafo e $centros$ é a lista de centros calculados anteriormente}
		\State $ParticaoPorVertice \gets $ \{\}
		\State $ListaDeVerticesPorCentro \gets $ \{\}
		\State $ParticaoDoCentro \gets $ \{\}
		\For{$i \in 1\ ...\ |V|$}
			\If{$i \in centros$}
				\State $ParticaoPorVertice[i] \gets i$
			\Else
				\State $ParticaoPorVertice[i] \gets -1$
			\EndIf
		\EndFor
		\For{$centro \in centros$}
			\State $ListaDeVerticesPorCentro(centro) \gets $ lista dos nós do grafo ordenados pelas suas distâncias ao $centro$
			\State $ParticaoDoCentro(centro) \gets $ \{\}
		\EndFor
		\Repeat
			\For{$C_{i} \in centros$}
				\While{$ListaDeVerticesPorCentro(C_{i}) \neq \{\}$}
					\State $n \gets $ REMOVE-PRIMEIRO($ListaDeVerticesPorCentro(C_{i})$)
					\If{$ParticaoPorVertice(n) = -1$}
						\State $ParticaoPorVertice(n) \gets C_{i}$
						\State \textbf{Pare o Laço Enquanto}
					\EndIf
				\EndWhile
			\EndFor
		\Until{$-1 \notin ParticaoPorVertice$} \Comment{Até que todo vértice esteja em uma partição}
		\For{$v \in V$}
			\State $ParticaoDoCentro(ParticaoPorVertice(v)) \cup $ {o menor caminho entre ParticaoPorVertice(v) e v}
		\EndFor
		\State \textbf{Retorne} as partições em $ParticaoDoCentro$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa criando uma lista chamada $ParticaoPorVertice$. Nessa lista, 
cada índice representa um vértice, $v$, do grafo. O valor armazenado em 
$ParticaoPorVertice(v)$ corresponde ao centro ao qual o vértice $v$ está 
associado. No final, todos os vértices associados a um centro formarão uma 
partição diferente. Na linha seguinte é iniciada uma lista bidimensional. O 
índice da primeira dimensão representa um centro, $c$, calculado na etapa 
anterior da construção de indivíduos, e $ListaDeVerticesPorCentro(c)$ representa 
uma lista de todos os vértices do grafo ordenados pelas suas distâncias a $c$. 
Na linha 4 é criada outra lista bidimensional, cujos índices também representam 
cada centro já calculado. $ParticaoDoCentro(c)$ vai guardar uma lista de todos 
os vértices que foram associados a $c$. Em breve, será mostrado porque é 
necessário manter ambas as listas $ParticaoDoCentro$ e $ParticaoPorVertice$.

O operador segue para popular a lista $ParticaoPorVertice$ com os elementos 
triviais. Cada centro, $c$, tem seu valor em $ParticaoPorVertice$ configurado 
para si mesmo, enquanto que os outros vértices tem o valor configurado para $-1$. 
Na linha 13 é calculada a lista de vértices do grafo ordenadas pela distância ao 
centro e na linha 14 é iniciada a lista $ParticaoDoCentro$ para cada um dos 
centros.

O \textit{loop} iniciado na linha 16 só para quando todos os vértices estiverem 
associados a algum centro, dentro da lista $ParticaoPorVertice$. A cada iteração 
deste \textit{loop}, é encontrado, para cada centro, $c$, o primeiro vértice na 
sua $ListaDeVerticesPorCentro$  que ainda não possui um centro associado a si. 
Uma vez que esse vértice é encontrado, seu valor em $ParticaoPorVertice$ é 
configurado para o centro $c$.

Quando todos os vértices possuem um valor diferente de $-1$ em 
$ParticaoPorVertice$, o operador entra em seu último \textit{loop}. Nele, para 
cada vértice, $v$, do grafo é concatenada a lista que consiste no menor caminho 
entre $v$ e o centro, $c$, a ele associado em $ParticaoPorVertice$ com a lista 
de vértices na partição de $c$. Isso acontece para todas as partições possuam os 
vértices necessários para serem conectadas. E essa é a diferença entre as listas 
$ParticaoPorVertice$ e $ParticaoDoCentro$.

\subsection{\textit{Path Building}}
\label{path_building}

Uma vez de posse dos centros e das partições, falta construir um caminho, mais 
especificamente um ciclo, que permita ao agente caminhar por todos os nós de 
sua partição. A primeira abordagem a ser apresentada para tal finalidade, segue 
o mesmo princípio de ter uma opção totalmente aleatória, e é chamada de 
\textit{Random Path Building}. Observe o pseudocódigo~\ref{path_random}. Este 
procedimento deve ser executado para cada uma das partições calculadas na etapa 
de \textit{Partitioning}.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Random Path Building}}          % give the algorithm a caption
	\label{path_random}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                   % enter the algorithmic environment
		\Procedure{RANDOM-PATH-BUILDING}{$G(V,E), particao$}
		\newline
		\Comment{$G$ é o o grafo, $particao$ é a lista de vértices que formam a partição de um agente}
		\State $G^{\prime} \gets $ subgrafo de $G$ induzido por $particao$
		\State $particao \gets $ EMBARALHA($particao$) \Comment{Embaralha a lista de vértices aleatoriamente}
		\State $Q \gets $ LISTA-CICLICA($particao$)
		\State $P \gets $ \{\} \Comment{$P$ é o caminho resultante}
		\For{$i = 1$ até $|Q|$}
			\If{existe aresta em $G^{\prime}$ entre $Q[i]$ e $Q[i+1]$}
				\State ADICIONA-AO-CAMINHO($P$, $Q[i]$)
				\State ADICIONA-AO-CAMINHO($P$, $Q[i+1]$)
			\Else
				\State $p \gets $ menor caminho entre $Q[i]$ e $Q[i+1]$
				\For{$v \in p$}
					\State ADICIONA-AO-CAMINHO($P$, $v$)
				\EndFor
			\EndIf
		\EndFor
		\State \textbf{Retorne} $P$
		\EndProcedure
		\Procedure{ADICIONA-AO-CAMINHO}{$P$, $v$}
		\State $ultimo \gets $ PEEK-LAST($P$) \Comment{Retorna o último elemento de P sem removê-lo}
		\If{$ultimo \neq nulo$ \textbf{e} $ultimo = v$}
			\State \textbf{Retorne}
		\Else
			\State $P \gets P\ \cup $ \{$v$\}
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Perceba que, como $Q$ é uma lista cíclica, na última iteração do \textit{loop} 
da linha 6, $Q[i+1]$ será o primeiro elemento de $Q$. Assim, o menor caminho 
entre o último e o primeiro elemento de $Q$ será adicionado ao caminho final 
$P$. Isto fará com que $P$ seja um ciclo, já que ele irá começar e terminar no 
primeiro elemento de $Q$.

\section{Mutação}

Uma vez que os operadores para criação arbitrária de indivíduos estejam 
apresentados, fica faltando os operadores de mutação e recombinação para que 
se possa executar um algoritmo evolucionário completo no contexto da \ac{tmap}.
Nesta seção, por tanto, serão apresentados dois operadores diferentes para 
aplicar mutação em indivíduos.

No entanto, antes de descrever os operadores, será mostrado um procedimento que 
é utilizado em ambos. Ao final de sua operação, as mutações aqui propostas 
aplicam um procedimento baseado no \textit{$k-$change} 
\citep{Marx:2008:SKN:2283963.2284596}, que será chamado de \textit{melhorar}. O 
\textit{$k-$change} é descrito como uma heurística de busca local que tenta 
encontrar um caminho de menor custo através de leves alterações em um caminho 
original. A alteração é a substituição de até $k$ arestas no caminho. Os valores 
para $k$ mais utilizados são 2, 3 e 4. Como o objetivo do operador de mutação é 
realizar uma leve mudança no indivíduo \citep{Luke2013Metaheuristics}, esta 
pesquisa utilizou $k = 2$.

O pseudocódigo~\ref{melhorar} ilustra o procedimento de \textit{melhorar}, que 
engloba o uso do \textit{2-change}.

\begin{algorithm}                  % enter the algorithm environment
	\caption{Melhorar (\textit{2-change})}          % give the algorithm a caption
	\label{melhorar}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                    % enter the algorithmic environment
		\Procedure{MELHORAR}{$G(V,E), A$}
		\newline
		\Comment{$G$ é o grafo e $A$ é o Agente escolhido para sofrer mutação}
		\Repeat
			\State $p \gets $ RANDOM-2-CHANGE($G(V,E)$, $A$)
			\If{CUSTO($p$) < CUSTO($A$)}
				\State CONFIGURAR-CAMINHO($A$, $p$) \Comment{Substitui o caminho antigo do Agent}	
			\EndIf
		\Until{não tenhamos mais tempo}
		\EndProcedure
		\Procedure{RANDOM-2-CHANGE}{$G(V,E), A$}
			\State $edge_{1} \gets 0$
			\State $edge_{2} \gets 0$
			\State $p \gets $ caminho do agente $A$
			\Repeat
				\State $edge_{1} \gets $ escolhe um número aleatório entre 1 e $|p| -1$
				\State $edge_{2} \gets $ escolhe um número aleatório entre 1 e $|p| -1$
				\Comment{$-1$ porque o último e o primeiro elementos são iguais}
				\If{$edge_{1} > edge_{2}$} \Comment{Forçar que $edge_{1}$ seja o elemento mais a esquerda de $p$}
					\State $aux \gets edge_{1}$
					\State $edge_{1} \gets edge_{2}$
					\State $edge_{2} \gets aux$
				\EndIf
			\Until{$edge_{1} \neq edge_{2}$ \textbf{e} $edge_{1} + 1 \neq edge_{2}$}
			\State \textbf{Retorne} 2-CHANGE($G(V,E)$, $A$, $edge_{1}$, $edge_{2}$) 
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Primeiramente, é importante perceber que o \textit{2-change} não necessariamente 
irá retornar um caminho de custo menor. Então, o procedimento \textit{melhorar} 
só vai usar o caminho retornado pelo \textit{2-change} se houver ganho real. O 
procedimento \textit{RANDOM-2-CHANGE} vai selecionar duas arestas aleatoriamente. 
Contudo, o caminho do agente, $P$, está representado em uma lista de vértices 
onde, se $V_{i}$ e $V_{i+1}$ são dois vértices nas posições $i$ e $i+1$ dentro do 
caminho do agente, então existe uma aresta $(V_{i}, V_{i+1})$ no Grafo onde o 
agente patrulha. Então, quando o procedimento escolhe um valor $edge_{1}$, esse 
valor está representando, na verdade, a aresta $(V_{edge_{1}}, V_{edge_{1}+1})$.

Uma vez que o procedimento tem certeza de ter escolhido duas arestas diferentes, 
ele faz uma chamada para o \textit{2-change} em si, que está descrito no 
pseudocódigo~\ref{2_change}.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{2-change}}          % give the algorithm a caption
	\label{2_change}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                    % enter the algorithmic environment
		\Procedure{2-CHANGE}{$G(V,E), A, edge_{1}, edge_{2}$}
		\newline
		\Comment{$G$ é o grafo e $A$ é o Agente escolhido para sofrer mutação}
		\State $P \gets $ caminho do agente $A$
		\State $P^{\prime}  \gets $ \{\} \Comment{Novo caminho}
		\For{$k \in 1\ ...\ |p|$} \Comment{Lembrando que $edge_{1} < edge_{2}$}
			\If{$k < edge_{1}$}
				\State ADICIONA-AO-CAMINHO($P^{\prime}$, $P[k]$) \Comment{Vide pseudocódigo~\ref{path_random}}
			\ElsIf{$k = edge_{1}$}
				\State $p \gets $ menor caminho entre $P[edge_{1}]$ e $P[edge_{2}]$
				\For{cada $p_{i} \in p$}
					\State ADICIONA-AO-CAMINHO($P^{\prime}$, $p_{i}$)
				\EndFor
			\ElsIf{$k < edge_{2}$}
				\State $v \gets P[edge_{1} + edge_{2} - k]$ \Comment{lembrando que, nesse ponto, $k > edge_{1}$}
				\State ADICIONA-AO-CAMINHO($P^{\prime}$, $v$)
			\ElsIf{$k = edge_{2}$}
				\State $p \gets $ menor caminho entre $P[edge_{1}+1]$ e $P[edge_{2}+1]$
				\For{cada $p_{i} \in p$}
					\State ADICIONA-AO-CAMINHO($P^{\prime}$, $p_{i}$)
				\EndFor
			\Else
				\State ADICIONA-AO-CAMINHO($P^{\prime}$, $P[k]$)
			\EndIf
		\EndFor
		\State \textbf{Retorne} $P^{\prime}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O procedimento \textit{2-change} funciona da seguinte forma: seja $P$ o conjunto 
de pares ordenados (já que é uma lista) dos vértices no caminho do agente $A$. 
$P$ será algo como:
\begin{multline*}
\{<V_{1},1>,...,<V_{e_{1}},e_{1}>,<V_{e_{1}+1},e_{1}+1>,..., \\
<V_{e_{2}-1},e_{2}-1>,<V_{e_{2}},e_{2}>,<V_{e_{2}+1},e_{2}+1>,...,<V_{|P|},|P|>\}
\end{multline*}
Onde $e_{1}$ e $e_{2}$ são as duas arestas escolhidas para serem substituídas. 
Após a execução do \textit{2-change}, o caminho retornado, $P^{\prime}$, deverá 
ser:
\begin{multline*}
\{<V_{1},1>,...,<V_{e_{1}},e_{1}>,...,<V_{e_{2}},e_{2}>,<V_{e_{2}-1},e_{2}-1>,..., \\
<V_{e_{1}+1},e_{1}+1>,...,<V_{e_{2}+1},e_{2}+1>,...,<V_{|P|},|P|>\}
\end{multline*}

Veja um exemplo. Suponha que um agente, $A$, que percorre as arestas vermelhas 
no seu subgrafo induzido ilustrado na \figref{2_change_ex1}. O seu ciclo seria 
representado pela lista $P = [6,4,5,1,2,3,4,6]$. Suponha agora que esse agente 
passe pelo \textit{2-change} e que as arestas escolhidas foram $(4,5)$ e $(2,3)$, 
ou seja, $e_{1} = 2$ e $e_{2} = 5$. Então, $P^{\prime}$ será 
$[6,4,2,1,5,3,4,6]$. E é possível visualizar $P^{\prime}$ na 
\figref{2_change_ex2}.

\tikzstyle{vertex}=[circle,fill=black!25,minimum size=20pt,inner sep=0pt]
\tikzstyle{edge} = [draw,thick,-]
\tikzstyle{selected edge} = [draw,line width=2pt,-,red!50]

\begin{figure}
	\caption{Caminho original do Agente de exemplo para o procedimento \textit{2-change}}
	\centering
	\begin{tikzpicture}
		[scale=.8]
		\node[vertex] (n6) at (1,10) {6};
		\node[vertex] (n4) at (4,8)  {4};
		\node[vertex] (n5) at (8,9)  {5};
		\node[vertex] (n1) at (11,8) {1};
		\node[vertex] (n2) at (9,6)  {2};
		\node[vertex] (n3) at (5,5)  {3};
	
		\foreach \from/\to in {n2/n5,n3/n5,n4/n2}
			\path[edge] (\from) -- (\to);
		\foreach \source / \dest in {n6/n4,n4/n5,n5/n1,n1/n2,n2/n3,n3/n4}
			\path[selected edge] (\source) -- (\dest);
	
	
	\end{tikzpicture}
	\caption*{Fonte: O autor}
	\label{2_change_ex1}
\end{figure}

\begin{figure}
	\caption{Caminho do Agente de exemplo após o procedimento \textit{2-change}}
	\centering
	\begin{tikzpicture}
	[scale=.8]
	\node[vertex] (n6) at (1,10) {6};
	\node[vertex] (n4) at (4,8)  {4};
	\node[vertex] (n5) at (8,9)  {5};
	\node[vertex] (n1) at (11,8) {1};
	\node[vertex] (n2) at (9,6)  {2};
	\node[vertex] (n3) at (5,5)  {3};
	
	\foreach \from/\to in {n2/n5,n4/n5,n2/n3,n4/n2}
		\path[edge] (\from) -- (\to);
	\foreach \source / \dest in {n6/n4,n5/n1,n1/n2,n3/n4,n4/n2,n3/n5}
		\path[selected edge] (\source) -- (\dest);
	
	
	\end{tikzpicture}
	\caption*{Fonte: O autor}
	\label{2_change_ex2}
\end{figure}

Com o operador \textit{Melhorar} devidamente explicado, fica faltando os 
operadores de mutação em si, que vão fazer uma chamada para o procedimento de 
\textit{Melhorar}. O primeiro operador de mutação é chamado de 
\textit{Half Add Half Sub Small Changes}. O nome vem do fato de que existe 
uma change de $50\%$ do operador adicionar ou subtrair um vértice do caminho do 
agente selecionado para mutação, sempre de forma a modificar levemente o caminho.
O pseudocódigo~\ref{small_changes} ilustra o operador.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Half Add Half Sub Small Changes}}          % give the algorithm a caption
	\label{small_changes}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                   % enter the algorithmic environment
		\Procedure{HALF-ADD-HALF-SUB-SMALL-CHANGES}{$Solucao$}
		\newline
		\Comment{$Solucao$ é o indivíduo selecionado para mutação}
		\State $G(V,E) \gets $ o grafo associado à $Solucao$
		\State $A \gets $ um agente escolhido aleatoriamente
		\State $d \gets $ um número Real aleatório entre 0 e 1
		\If{$d \geq 0.5$}
			\State ADICIONA-COM-POUCAS-MUDANÇAS($G(V,E)$,$A$)
		\Else
			\State REMOVE-COM-POUCAS-MUDANÇAS($G(V,E)$,$A$)
		\EndIf
		\State MELHORAR($G(V,E)$, $A$)
		\EndProcedure
		\Procedure{ADICIONA-COM-POUCAS-MUDANÇAS}{$G(V,E), A$}
		\State $P \gets $ o caminho do agente $A$
		\State $v \gets $ um vértice aleatório tal que $v \in V$ e $v \notin P$
		\State $d \gets \infty$
		\State $v^{\prime} \gets $ nulo
		\For{$i \in 1\ ...\ |P|$}
			$d_{i} \gets $ DISTANCIA($G(V,E)$, $v$, $P[i]$)
			\If{$v^{\prime} = $ nulo \textbf{ou} $d^{\prime} < d$}
				$v^{\prime} \gets P[i]$
				\State $d \gets d_{i}$
			\EndIf
		\EndFor
		\State $P^{\prime} \gets $ menor caminho entre $v^{\prime}$ e $v$
		\For{$k \in 1\ ...\ (|P^{\prime}| - 1)$}
			ADICIONA-AO-CAMINHO($P$, $i + k$, $P^{\prime}[k]$)
			\State ADICIONA-AO-CAMINHO($P$, $i + k$, $P^{\prime}[k]$)
		\EndFor
		\State ADICIONA-AO-CAMINHO($P$, $i + k + 1$, $P^{\prime}[k + 1]$)
		\EndProcedure
		\Procedure{REMOVE-COM-POUCAS-MUDANÇAS}{$G(V,E), A$}
		\State $P \gets $ o caminho do agente $A$
		\State $indice \gets $ um número aleatório entre $1$ e $|P|$
		\State $P^{\prime} \gets $ \{\}
		\If{$indice = 1$ \textbf{ou} $indice = |P|$}
			REMOVE-PRIMEIRO-ELEMENTO($P$)
			\State REMOVE-ULTIMO-ELEMENTO($P$)
			\State $P^{\prime} \gets $ menor caminho entre $P[|P|]$ e $P[1]$
			\State $indice \gets |P|$
		\ElsIf{$P[indice - 1] = P[indice + 1]$}
			\State REMOVE-ELEMENTO-NO-INDICE($P$, $indice$)
			\State REMOVE-ELEMENTO-NO-INDICE($P$, $indice$)
		\Else
			$P^{\prime} \gets $ menor caminho entre $P[indice - 1]$ e $P[indice + 1]$
			\State REMOVE-ELEMENTO-NO-INDICE($P$, $indice$)
		\EndIf
		\For{cada $v_{j} \in P^{\prime}$}
			ADICIONA-AO-CAMINHO($P$, $indice$, $v_{j}$)
			\State $indice \gets indice + 1$
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Quando o operador executa a adição de um vértice, $v$, ele procura pelo vértice, 
$v^{\prime}$ que já está no caminho do agente com menor distância para $v$. 
Depois, ele inclui no caminho do agente uma rota que vai do vértice $v$ para o 
vértice $v^{\prime}$ e volta para $v$. Por isso, há duas operações de adição 
nas linhas 22 e 23: o operador está adicionando o caminho de ida e de volta ao 
mesmo tempo. Já para remover um vértice, $v$, do caminho do agente, o operador, 
primeiro, verifica se o vértice a ser removido é o primeiro (e último, já que é 
um ciclo). Em caso positivo, o primeiro e último elementos da lista que 
representa o caminho do agente são removidos e então o menor caminho entre os 
novos último e primeiro vértices é adicionado ao final do ciclo do agente 
(linhas 32 a 35). Caso o caminho do agente parta de um vértice $v_{i}$, visite o 
vértice escolhido e volte para o mesmo vértice $v_{i}$, então o operador 
simplesmente apaga $v$ e uma das cópias de $v_{i}$ (linhas 36 a 38). Por fim, 
caso nenhuma dessas condições seja verdadeira, o operador irá remover o vértice 
escolhido e substituí-lo pelo menor caminho entre seu antecessor e seu sucessor 
(linhas 39 a 41).

Para concluir os operadores de mutação, falta o operador 
\textit{Half Add Half Sub Rebuild}. Ele compartilha com o 
\textit{Half Add Half Sub Small Changes} a chance de 50\% de adicionar ou 
remover um vértice do caminho do agente. No entanto, este operador tem como 
objetivo causar alterações mais drásticas no caminho do agente, pois ele o
reconstrói integralmente. O pseudocódigo~\ref{rebuild} ilustra este operador.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Half Add Half Sub Rebuild}}          % give the algorithm a caption
	\label{rebuild}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                   % enter the algorithmic environment
		\Procedure{HALF-ADD-HALF-SUB-REBUILD}{$Solucao$}
		\newline
		\Comment{$Solucao$ é o indivíduo selecionado para mutação}
		\State $G(V,E) \gets $ o grafo associado à $Solucao$
		\State $A \gets $ um agente escolhido aleatoriamente
		\State $d \gets $ um número Real aleatório entre 0 e 1
		\If{$d \geq 0.5$}
			\State ADICIONA-E-RECONSTROI($G(V,E)$,$A$)
		\Else
			\State REMOVE-E-RECONSTROI($G(V,E)$,$A$)
		\EndIf
		\State MELHORAR($G(V,E)$, $A$)
		\EndProcedure
		\Procedure{ADICIONA-E-RECONSTROI}{$G(V,E), A$}
		\State $P \gets $ o caminho do agente $A$
		\State $v \gets $ um vértice aleatório tal que $v \in V$ e $v \notin P$
		\State $particao \gets $ a partição por onde patrulha o agente $A$
		\State $particao \gets particao\ \cup $ \{$v$\}
		\State $P \gets $ RECONSTRÓI-O-CAMINHO($G(V,E)$, $particao$)
		\EndProcedure
		\Procedure{REMOVE-E-RECONSTROI}{$G(V,E), A$}
		\State $P \gets $ o caminho do agente $A$
		\State $particao \gets $ a partição por onde patrulha o agente $A$
		\State $lista \gets $ EMBARALHA($particao$) \Comment{Embaralha de forma aleatória}
		\For{$v \in lista$}
			\State $particao^{\prime} \gets particao - \{v\}$
			\State $G^{\prime} \gets $ subgrafo de $G$ induzido por $particao^{\prime}$
		\EndFor
		\State $particao \gets particao^{\prime}$
		\State RECONSTRÓI-O-CAMINHO($G(V,E)$, $particao$)
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Caso o \textit{Half Add Half Sub Rebuild} opere para adicionar um novo vértice, 
$v$, à lista de vértices patrulhados pelo agente, $A$, ele irá simplesmente 
adicionar $v$ à partição associada a $A$. Depois, o caminho que $A$ tem de 
percorrer é completamente reconstruído usando qualquer um dos operadores 
apresentados na \secref{path_building}. Por isso, o 
\textit{Half Add Half Sub Rebuild} deve gerar alterações mais bruscas nos 
indivíduos quando comparado com o \textit{Half Add Half Sub Small Changes}.

Caso a operação seja de remoção, o operador irá procurar um vértice da partição 
do agente que possa ser removido sem desconectar o seu subgrafo induzido. Quando 
este vértice é encontrado ele é removido e um novo caminho é calculado para 
o agente. De forma análoga à operação de adição, o novo caminho pode ser 
construído utilizando qualquer um dos operadores de \textit{path building} 
apresentados neste capítulo.

\section{Recombinação}

Por fim, será apresentado um operador para aplicar recombinação em dois 
indivíduos pais gerando dois indivíduos filhos. Esse operador é chamado de 
\textit{Simple Random Crossover}, ou Recombinação Aleatória Simples, e está 
ilustrado no pseudocódigo~\ref{recombinacao}. O operador consiste em tentar 
trocar um agente de um indivíduo por um agente do outro indivíduo selecionado 
para recombinação.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Simple Random Crossover}}          % give the algorithm a caption
	\label{recombinacao}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                   % enter the algorithmic environment
		\Procedure{SIMPLE-RANDOM-CROSSOVER}{$Solucao_{a}, Solucao_{b}, r$}
		\newline
		\Comment{Os parâmetros são dois indivíduos e $r$, o número de agentes}
		\State $r_{i} \gets $ escolhe um número aleatório entre $1\ ...\ r$
		\State $C_{a} \gets $ Cópia($Solucao_{a}$) \Comment{Este é o filho do indivíduo $a$}
		\State $C_{b} \gets $ Cópia($Solucao_{b}$) \Comment{Este é o filho do indivíduo $b$}
		\State $Agente_{a} \gets $ RETORNA-AGENTE($C_{a}$, $r_{i}$)
		\State $Agente_{b} \gets $ RETORNA-AGENTE($C_{b}$, $r_{i}$)
		\If{o centro do $Agente_{a}$ for igual ao centro do $Agente_{b}$}
			\State CONFIGURA-AGENTE($C_{a}$, $r_{i}$, $Agente_{b}$)
			\State CONFIGURA-AGENTE($C_{b}$, $r_{i}$, $Agente_{a}$)
			\State \textbf{Retorne} $C_{a}$, $C_{b}$
		\Else
			\For{$j \in 1\ ...\ r$}
				\State $agente \gets $ RETORNA-AGENTE($C_{b}$, $j$)
				\If{o centro do $Agente_{a}$ está no caminho do $agente$}
					\State $Agente_{b} \gets agente$
					\State CONFIGURA-AGENTE($C_{a}$, $r_{i}$, $Agente_{b}$)
					\State CONFIGURA-AGENTE($C_{b}$, $j$, $Agente_{a}$)
					\State \textbf{Retorne} $C_{a}$, $C_{b}$
				\EndIf
			\EndFor
			\State CONFIGURA-AGENTE($C_{a}$, $r_{i}$, $Agente_{b}$)
			\State CONFIGURA-AGENTE($C_{b}$, $r_{i}$, $Agente_{a}$)
			\State \textbf{Retorne} $C_{a}$, $C_{b}$
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa escolhendo um índice, $r_{i}$ de um agente aleatoriamente. 
Depois, uma cópia dos indivíduos é atribuída a dois novos indivíduos filhos. 
A seguir, o operador verifica se os agentes no índice $r_{i}$ possuem o mesmo 
vértice como centro. Em caso positivo, o operador imediatamente troca um agente 
pelo outro entre os dois indivíduos filhos. Em caso negativo, o operador tenta 
encontrar o agente do indivíduo $b$ cujo caminho passe pelo centro do agente 
posicionado no índice $r_{i}$ do indivíduo $a$. Encontrando este agente, o 
operador faz a troca. Caso não seja encontrado nenhum agente, o operador vai 
simplesmente trocar os agentes que estão no mesmo índice, $r_{i}$, em seus 
respectivos indivíduos.