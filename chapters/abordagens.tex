\chapter{Abordagens Evolucionárias para a TMAP}

No último capítulo, foram apresentados os algoritmos evolucionários usados nesta 
pesquisa. No entanto, algumas lacunas ficaram abertas: não foram apresentadas 
formas de gerar indivíduos, isto é, soluções para a \ac{tmap}, de forma 
arbitrária para a primeira população, além de como aplicar 
recombinação e mutação neles. Dessa forma, neste capítulo, serão propostos 
operadores para construção de indivíduos, bem como para mutação e recombinação.

\section{Criação de Indivíduos}

Assim como em \citep{Pippin:2013:PBT:2480362.2480378} e \citep{4630897}, as 
soluções resultantes das abordagens evolucionárias aqui propostas são baseadas 
em particionamento (vide \secref{sec:classifytmap}). Dessa forma, a criação de 
indivíduos foi dividida em três etapas. A primeira é o cálculo de $r$ centros, 
onde $r$ é o número de agentes, ao redor dos quais os agentes deverão patrulhar. 
A segunda tarefa é a escolha dos nós, ao redor do centro, que comporão cada 
partição. Por fim, falta o cálculo de um ciclo, para cada partição, que passe 
por todos os seus nós. Essas tarefas foram chamadas respectivamente de 
\textit{centering}, \textit{partitioning} e \textit{path building}.

Nas subseções seguintes, cada uma dessas três tarefas serão tratadas 
separadamente, mas é importante notar que uma tarefa depende da resposta dada 
pela sua antecessora.

\subsection{\textit{Centering}}

A primeira forma proposta para se calcular os centros é chamada de 
\textit{Random Centering}, e consiste em simplesmente escolher nós aleatórios do 
grafo para ser os centros. Veja o Pseudocódigo~\ref{centering_random} abaixo.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Random Centering}}          % give the algorithm a caption
	\label{centering_random}                           % and a label for \ref{} commands later in the document
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{RANDOM-CENTERING}{$V, r$}
		\newline
		\Comment{$V$ é o conjunto de vértices do grafo e $r$ é o número de agentes}
		\State $Vertices \gets $ Cópia($V$)
		\State $Centros \gets \{\}$
		\For{$1 ...\ r$}
			\State $Centros \gets Centros\ \cup$ \{Seleciona-Aleatoriamente-Remove($Vertices$)\}
		\EndFor
		\State \textbf{Retorne} $Centros$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Uma outra forma de escolher os centros é tentar encontrar os vértices do grafo 
que estejam mais distantes uns dos outros. O objetivo neste operador é iniciar 
indivíduos de forma um pouco mais inteligente, para aumentar as chances de 
serem indivíduos com alta aptidão, mas sem apagar completamente o lado aleatório 
indicado às inicializações de indivíduos nos algoritmos evolucionários. 
\citep{Luke2013Metaheuristics} alerta os seus leitores para os perigos de 
utilizar heurísticas que aparentam gerar melhores indivíduos, mas que podem 
estar, inadvertidamente, condenando os algoritmos evolucionários a ficarem 
"presos"\ em mínimos locais.

O pseudocódigo~\ref{centering_maximum} mostra como seria a implementação deste 
operador.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Approximated Maximum Distance Centering}}          % give the algorithm a caption
	\label{centering_maximum}                           % and a label for \ref{} commands later in the document
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{APPROXIMATED-MAXIMUM-DISTANCE-CENTERING}{$G(V,E), r$}
		\newline
		\Comment{$G(V,E)$ é o grafo e $r$ é o número de agentes}
		\State $Vertices \gets $ Cópia($V$)
		\State $Centros \gets $ RANDOM-CENTERING($V$, $r$)
		\State $d \gets $ Soma-Distancias($G(V,E)$, $centros$) \Comment{Soma as distâncias entre os vértices}
		\Repeat
			\State $centro \gets $ escolhe um vértice aleatório de $centros$
			\For{$V_{i} \in $ Sucessores($G(V,E)$, $centro$), onde $V_{i} \notin Centros$}
				\State Substitui($Centros$, $centro$, $V_{i}$) \Comment{Substitui $centro$ por $V_{i}$ em $Centros$}
				\State $d^{\prime} \gets $ Soma-Distancias($G(V,E)$, $centros$)
				\If{$d > d^{\prime}$}
					\State Substitui($Centros$, $V_{i}$, $centro$)
				\EndIf
			\EndFor
		\Until{não tenhamos mais tempo}
		\State \textbf{Retorne} $Centros$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa selecionando $r$ centros aleatoriamente, onde $r$ é o número 
de agentes. Depois, ele calcula o somatório das distâncias entre todos os $r$ 
vértices. Então, a cada iteração, um centro é escolhido aleatoriamente. Todos 
os sucessores do centro escolhido são testados no lugar do centro, se essa troca 
fizer com que os somatórios das distâncias entre os centros aumente, o sucessor 
fica no lugar do centro.

\subsection{\textit{Partitioning}}

Seguindo a mesma ideia de ter uma opção completamente aleatória de criar os 
indivíduos, uma das formas propostas para calcular as partições é chamada de 
\textit{Random Partitioning}. O pseudocódigo~\ref{partitioning_random} 
exemplifica como isso pode ser implementado.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Random Partitioning}}          % give the algorithm a caption
	\label{partitioning_random}                           % and a label for \ref{} commands later in the document
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{RANDOM-PARTITIONING}{$centros, G(V,E)$}
		\newline
		\Comment{$G$ é o o grafo e $centros$ é a lista de centros calculados anteriormente}
		\State $Particoes \gets $ \{\}
		\State $verticesAdicionados \gets $ \{\}
		\Repeat
			\State $centro \gets $ escolhe aleatoriamente um elemento de $centros$
			\State $candidato \gets $ Seleciona-Aleatoriamente($V$) \Comment{$candidato \notin centros$}
			\State $caminho \gets $ Menor-Caminho($G$, $centro$, $candidato$)
			\State $Particoes(centro) \gets Particoes(centro)\ \cup caminho$
			\State $verticesAdicionados \gets verticesAdicionados\ \cup caminho$
		\Until{$|verticesAdicionados| = |V|$}
		\State \textbf{Retorne} $Particoes$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O \textit{Random Partitioning} consiste em criar uma lista de partições para 
cada centro. A cada iteração do \textit{loop} principal, um centro é escolhido 
aleatoriamente. Então, um outro vértice do grafo também é escolhido de forma 
aleatória (desde que não seja um centro). Depois, é adicionado à partição 
daquele centro escolhido todo o menor caminho entre ele mesmo e o vértice 
escolhido. O menor caminho inteiro é adicionado para que as partições estejam 
conectadas, isto é, para que seja possível traçar um caminho, dentro do grafo 
$G$, entre seus vértices. Finalmente, o \textit{Random Partitioning} para quando 
todos os nós do grafo estiverem em alguma partição.

Como o outro operador de particionamento do grafo é mais complexo, primeiro 
será apresentado o pseudocódigo ao leitor, e então será feita uma discussão 
de suas propriedades. Observe o pseudocódigo~\ref{partitioning_fungal}.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Heuristic Graph Partitioning}}          % give the algorithm a caption
	\label{partitioning_fungal}                           % and a label for \ref{} commands later in the document
	\begin{algorithmic}[1]                    % enter the algorithmic environment
		\Procedure{GRAPH-PARTITIONING}{$centros, G(V,E)$}
		\newline
		\Comment{$G$ é o o grafo e $centros$ é a lista de centros calculados anteriormente}
		\State $ParticaoPorVertice \gets $ \{\}
		\State $ListaDeVerticesPorCentro \gets $ \{\}
		\State $ParticaoDoCentro \gets $ \{\}
		\For{$i \in 1\ ...\ |V|$}
			\If{$i \in centros$}
				\State $ParticaoPorVertice[i] \gets i$
			\Else
				\State $ParticaoPorVertice[i] \gets -1$
			\EndIf
		\EndFor
		\For{$centro \in centros$}
			\State $ListaDeVerticesPorCentro(centro) \gets $ lista dos nós do grafo ordenados pelas suas distâncias ao $centro$
			\State $ParticaoDoCentro(centro) \gets $ \{\}
		\EndFor
		\Repeat
			\For{$C_{i} \in centros$}
				\While{$ListaDeVerticesPorCentro(C_{i}) \neq \{\}$}
					\State $n \gets $ REMOVE-PRIMEIRO($ListaDeVerticesPorCentro(C_{i})$)
					\If{$ParticaoPorVertice(n) = -1$}
						\State $ParticaoPorVertice(n) \gets C_{i}$
						\State \textbf{Pare o Laço Enquanto}
					\EndIf
				\EndWhile
			\EndFor
		\Until{$-1 \notin ParticaoPorVertice$} \Comment{Até que todo vértice esteja em uma partição}
		\For{$v \in V$}
			\State $ParticaoDoCentro(ParticaoPorVertice(v)) \cup $ {o menor caminho entre ParticaoPorVertice(v) e v}
		\EndFor
		\State \textbf{Retorne} as partições em $ParticaoDoCentro$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa criando uma lista chamada $ParticaoPorVertice$. Nessa lista, 
cada índice representa um vértice, $v$, do grafo. O valor armazenado em 
$ParticaoPorVertice(v)$ corresponde ao centro ao qual o vértice $v$ está 
associado. No final, todos os vértices associados a um centro formarão uma 
partição diferente. Na linha seguinte é iniciada uma lista bidimensional. O 
índice da primeira dimensão representa um centro, $c$, calculado na etapa 
anterior da construção de indivíduos, e $ListaDeVerticesPorCentro(c)$ representa 
uma lista de todos os vértices do grafo ordenados pelas suas distâncias a $c$. 
Na linha 4 é criada outra lista bidimensional, cujos índices também representam 
cada centro já calculado. $ParticaoDoCentro(c)$ vai guardar uma lista de todos 
os vértices que foram associados a $c$. Em breve, será mostrado porque é 
necessário manter ambas as listas $ParticaoDoCentro$ e $ParticaoPorVertice$.

O operador segue para popular a lista $ParticaoPorVertice$ com os elementos 
triviais. Cada centro, $c$, tem seu valor em $ParticaoPorVertice$ configurado 
para si mesmo, enquanto que os outros vértices tem o valor configurado para $-1$. 
Na linha 13 é calculada a lista de vértices do grafo ordenadas pela distância ao 
centro e na linha 14 é iniciada a lista $ParticaoDoCentro$ para cada um dos 
centros.

O \textit{loop} iniciado na linha 16 só para quando todos os vértices estiverem 
associados a algum centro, dentro da lista $ParticaoPorVertice$. A cada iteração 
deste \textit{loop}, é encontrado, para cada centro, $c$, o primeiro vértice na 
sua $ListaDeVerticesPorCentro$  que ainda não possui um centro associado a si. 
Uma vez que esse vértice é encontrado, seu valor em $ParticaoPorVertice$ é 
configurado para o centro $c$.

Quando todos os vértices possuem um valor diferente de $-1$ em 
$ParticaoPorVertice$, o operador entra em seu último \textit{loop}. Nele, para 
cada vértice, $v$, do grafo é concatenada a lista que consiste no menor caminho 
entre $v$ e o centro, $c$, a ele associado em $ParticaoPorVertice$ com a lista 
de vértices na partição de $c$. Isso acontece para todas as partições possuam os 
vértices necessários para serem conectadas. E essa é a diferença entre as listas 
$ParticaoPorVertice$ e $ParticaoDoCentro$.

\subsection{\textit{Path Building}}