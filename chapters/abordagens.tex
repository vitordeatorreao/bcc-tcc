\chapter{Abordagens Evolucionárias para a TMAP}

No último capítulo, foram apresentados os algoritmos evolucionários usados nesta 
pesquisa. No entanto, algumas lacunas ficaram abertas: não foram apresentadas 
formas de gerar indivíduos, isto é, soluções para a \ac{tmap}, de forma 
arbitrária para a primeira população, além de como aplicar 
recombinação e mutação neles. Dessa forma, neste capítulo, serão propostos 
operadores para construção de indivíduos, bem como para mutação e recombinação.

\section{Criação de Indivíduos}

Assim como em \citep{Pippin:2013:PBT:2480362.2480378} e \citep{4630897}, as 
soluções resultantes das abordagens evolucionárias aqui propostas são baseadas 
em particionamento (vide \secref{sec:classifytmap}). Dessa forma, a criação de 
indivíduos foi dividida em três etapas. A primeira é o cálculo de $r$ centros, 
onde $r$ é o número de agentes, ao redor dos quais os agentes deverão patrulhar. 
A segunda tarefa é a escolha dos nós, ao redor do centro, que comporão cada 
partição. Por fim, falta o cálculo de um ciclo, para cada partição, que passe 
por todos os seus vértices. Essas tarefas foram chamadas respectivamente de 
\textit{centering}, \textit{partitioning} e \textit{path building}.

Nas subseções seguintes, cada uma dessas três tarefas serão tratadas 
separadamente, mas é importante notar que uma tarefa depende da resposta dada 
pela sua antecessora. Serão apresentadas mais de um operador que executa cada 
tarefa, assim ao montar um algoritmo evolucionário, o leitor pode construir 
seus indivíduos com qualquer combinação deles.

\subsection{\textit{Centering}}

A primeira forma proposta para se calcular os centros é chamada de 
\textit{Random Centering}, e consiste em simplesmente escolher nós aleatórios do 
grafo para ser os centros. Veja o Pseudocódigo~\ref{centering_random} abaixo.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Random Centering}}          % give the algorithm a caption
	\label{centering_random}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{RANDOM-CENTERING}{$V, r$}
		\newline
		\Comment{$V$ é o conjunto de vértices do grafo e $r$ é o número de agentes}
		\State $Vertices \gets $ Cópia($V$)
		\State $Centros \gets \{\}$
		\For{$1 ...\ r$}
			\State $Centros \gets Centros\ \cup$ \{Seleciona-Aleatoriamente-Remove($Vertices$)\}
		\EndFor
		\State \textbf{Retorne} $Centros$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Uma outra forma de escolher os centros é tentar encontrar os vértices do grafo 
que estejam mais distantes uns dos outros. O objetivo neste operador é iniciar 
indivíduos de forma um pouco mais inteligente, para aumentar as chances de 
serem indivíduos com alta aptidão, mas sem apagar completamente o lado aleatório 
indicado às inicializações de indivíduos nos algoritmos evolucionários. 
\citep{Luke2013Metaheuristics} alerta os seus leitores para os perigos de 
utilizar heurísticas que aparentam gerar melhores indivíduos, mas que podem 
estar, inadvertidamente, condenando os algoritmos evolucionários a ficarem 
"presos"\ em mínimos locais.

O pseudocódigo~\ref{centering_maximum} mostra como seria a implementação deste 
operador.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Approximated Maximum Distance Centering}}          % give the algorithm a caption
	\label{centering_maximum}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{APPROXIMATED-MAXIMUM-DISTANCE-CENTERING}{$G(V,E), r$}
		\newline
		\Comment{$G(V,E)$ é o grafo e $r$ é o número de agentes}
		\State $Vertices \gets $ Cópia($V$)
		\State $Centros \gets $ RANDOM-CENTERING($V$, $r$)
		\State $d \gets $ Soma-Distancias($G(V,E)$, $centros$) \Comment{Soma as distâncias entre os vértices}
		\Repeat
			\State $centro \gets $ escolhe um vértice aleatório de $centros$
			\For{$V_{i} \in $ Sucessores($G(V,E)$, $centro$), onde $V_{i} \notin Centros$}
				\State Substitui($Centros$, $centro$, $V_{i}$) \Comment{Substitui $centro$ por $V_{i}$ em $Centros$}
				\State $d^{\prime} \gets $ Soma-Distancias($G(V,E)$, $centros$)
				\If{$d > d^{\prime}$}
					\State Substitui($Centros$, $V_{i}$, $centro$)
				\EndIf
			\EndFor
		\Until{não tenhamos mais tempo}
		\State \textbf{Retorne} $Centros$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa selecionando $r$ centros aleatoriamente, onde $r$ é o número 
de agentes. Depois, ele calcula o somatório das distâncias entre todos os $r$ 
vértices. Então, a cada iteração, um centro é escolhido aleatoriamente. Todos 
os sucessores do centro escolhido são testados no lugar do centro, se essa troca 
fizer com que os somatórios das distâncias entre os centros aumente, o sucessor 
fica no lugar do centro.

\subsection{\textit{Partitioning}}

Seguindo a mesma ideia de ter uma opção completamente aleatória de criar os 
indivíduos, uma das formas propostas para calcular as partições é chamada de 
\textit{Random Partitioning}. O pseudocódigo~\ref{partitioning_random} 
exemplifica como isso pode ser implementado.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Random Partitioning}}          % give the algorithm a caption
	\label{partitioning_random}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}                    % enter the algorithmic environment
		\Procedure{RANDOM-PARTITIONING}{$centros, G(V,E)$}
		\newline
		\Comment{$G$ é o o grafo e $centros$ é a lista de centros calculados anteriormente}
		\State $Particoes \gets $ \{\}
		\State $verticesAdicionados \gets $ \{\}
		\Repeat
			\State $centro \gets $ escolhe aleatoriamente um elemento de $centros$
			\State $candidato \gets $ Seleciona-Aleatoriamente($V$) \Comment{$candidato \notin centros$}
			\State $caminho \gets $ Menor-Caminho($G$, $centro$, $candidato$)
			\State $Particoes(centro) \gets Particoes(centro)\ \cup caminho$
			\State $verticesAdicionados \gets verticesAdicionados\ \cup caminho$
		\Until{$|verticesAdicionados| = |V|$}
		\State \textbf{Retorne} $Particoes$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O \textit{Random Partitioning} consiste em criar uma lista de partições para 
cada centro. A cada iteração do \textit{loop} principal, um centro é escolhido 
aleatoriamente. Então, um outro vértice do grafo também é escolhido de forma 
aleatória (desde que não seja um centro). Depois, é adicionado à partição 
daquele centro escolhido todo o menor caminho entre ele mesmo e o vértice 
escolhido. O menor caminho inteiro é adicionado para que as partições estejam 
conectadas, isto é, para que seja possível traçar um caminho, dentro do grafo 
$G$, entre seus vértices. Finalmente, o \textit{Random Partitioning} para quando 
todos os nós do grafo estiverem em alguma partição.

Como o outro operador de particionamento do grafo é mais complexo, primeiro 
será apresentado o pseudocódigo ao leitor, e então será feita uma discussão 
de suas propriedades. Observe o pseudocódigo~\ref{partitioning_fungal}.

\begin{algorithm}                  % enter the algorithm environment
	\caption{\textit{Heuristic Graph Partitioning}}          % give the algorithm a caption
	\label{partitioning_fungal}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                    % enter the algorithmic environment
		\Procedure{GRAPH-PARTITIONING}{$centros, G(V,E)$}
		\newline
		\Comment{$G$ é o o grafo e $centros$ é a lista de centros calculados anteriormente}
		\State $ParticaoPorVertice \gets $ \{\}
		\State $ListaDeVerticesPorCentro \gets $ \{\}
		\State $ParticaoDoCentro \gets $ \{\}
		\For{$i \in 1\ ...\ |V|$}
			\If{$i \in centros$}
				\State $ParticaoPorVertice[i] \gets i$
			\Else
				\State $ParticaoPorVertice[i] \gets -1$
			\EndIf
		\EndFor
		\For{$centro \in centros$}
			\State $ListaDeVerticesPorCentro(centro) \gets $ lista dos nós do grafo ordenados pelas suas distâncias ao $centro$
			\State $ParticaoDoCentro(centro) \gets $ \{\}
		\EndFor
		\Repeat
			\For{$C_{i} \in centros$}
				\While{$ListaDeVerticesPorCentro(C_{i}) \neq \{\}$}
					\State $n \gets $ REMOVE-PRIMEIRO($ListaDeVerticesPorCentro(C_{i})$)
					\If{$ParticaoPorVertice(n) = -1$}
						\State $ParticaoPorVertice(n) \gets C_{i}$
						\State \textbf{Pare o Laço Enquanto}
					\EndIf
				\EndWhile
			\EndFor
		\Until{$-1 \notin ParticaoPorVertice$} \Comment{Até que todo vértice esteja em uma partição}
		\For{$v \in V$}
			\State $ParticaoDoCentro(ParticaoPorVertice(v)) \cup $ {o menor caminho entre ParticaoPorVertice(v) e v}
		\EndFor
		\State \textbf{Retorne} as partições em $ParticaoDoCentro$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa criando uma lista chamada $ParticaoPorVertice$. Nessa lista, 
cada índice representa um vértice, $v$, do grafo. O valor armazenado em 
$ParticaoPorVertice(v)$ corresponde ao centro ao qual o vértice $v$ está 
associado. No final, todos os vértices associados a um centro formarão uma 
partição diferente. Na linha seguinte é iniciada uma lista bidimensional. O 
índice da primeira dimensão representa um centro, $c$, calculado na etapa 
anterior da construção de indivíduos, e $ListaDeVerticesPorCentro(c)$ representa 
uma lista de todos os vértices do grafo ordenados pelas suas distâncias a $c$. 
Na linha 4 é criada outra lista bidimensional, cujos índices também representam 
cada centro já calculado. $ParticaoDoCentro(c)$ vai guardar uma lista de todos 
os vértices que foram associados a $c$. Em breve, será mostrado porque é 
necessário manter ambas as listas $ParticaoDoCentro$ e $ParticaoPorVertice$.

O operador segue para popular a lista $ParticaoPorVertice$ com os elementos 
triviais. Cada centro, $c$, tem seu valor em $ParticaoPorVertice$ configurado 
para si mesmo, enquanto que os outros vértices tem o valor configurado para $-1$. 
Na linha 13 é calculada a lista de vértices do grafo ordenadas pela distância ao 
centro e na linha 14 é iniciada a lista $ParticaoDoCentro$ para cada um dos 
centros.

O \textit{loop} iniciado na linha 16 só para quando todos os vértices estiverem 
associados a algum centro, dentro da lista $ParticaoPorVertice$. A cada iteração 
deste \textit{loop}, é encontrado, para cada centro, $c$, o primeiro vértice na 
sua $ListaDeVerticesPorCentro$  que ainda não possui um centro associado a si. 
Uma vez que esse vértice é encontrado, seu valor em $ParticaoPorVertice$ é 
configurado para o centro $c$.

Quando todos os vértices possuem um valor diferente de $-1$ em 
$ParticaoPorVertice$, o operador entra em seu último \textit{loop}. Nele, para 
cada vértice, $v$, do grafo é concatenada a lista que consiste no menor caminho 
entre $v$ e o centro, $c$, a ele associado em $ParticaoPorVertice$ com a lista 
de vértices na partição de $c$. Isso acontece para todas as partições possuam os 
vértices necessários para serem conectadas. E essa é a diferença entre as listas 
$ParticaoPorVertice$ e $ParticaoDoCentro$.

\subsection{\textit{Path Building}}

Uma vez de posse dos centros e das partições, falta construir um caminho, mais 
especificamente um ciclo, que permita ao agente caminhar por todos os nós de 
sua partição. A primeira abordagem a ser apresentada para tal finalidade, segue 
o mesmo princípio de ter uma opção totalmente aleatória, e é chamada de 
\textit{Random Path Building}. Observe o pseudocódigo~\ref{path_random}. Este 
procedimento deve ser executado para cada uma das partições calculadas na etapa 
de \textit{Partitioning}.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Random Path Building}}          % give the algorithm a caption
	\label{path_random}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                   % enter the algorithmic environment
		\Procedure{RANDOM-PATH-BUILDING}{$G(V,E), particao$}
		\newline
		\Comment{$G$ é o o grafo, $particao$ é a lista de vértices que formam a partição de um agente}
		\State $G^{\prime} \gets $ subgrafo de $G$ induzido por $particao$
		\State $particao \gets $ EMBARALHA($particao$) \Comment{Embaralha a lista de vértices aleatoriamente}
		\State $Q \gets $ LISTA-CICLICA($particao$)
		\State $P \gets $ \{\} \Comment{$P$ é o caminho resultante}
		\For{$i = 1$ até $|Q|$}
			\If{existe aresta em $G^{\prime}$ entre $Q[i]$ e $Q[i+1]$}
				\State ADICIONA-AO-CAMINHO($P$, $Q[i]$)
				\State ADICIONA-AO-CAMINHO($P$, $Q[i+1]$)
			\Else
				\State $p \gets $ menor caminho entre $Q[i]$ e $Q[i+1]$
				\For{$v \in p$}
					\State ADICIONA-AO-CAMINHO($P$, $v$)
				\EndFor
			\EndIf
		\EndFor
		\State \textbf{Retorne} $P$
		\EndProcedure
		\Procedure{ADICIONA-AO-CAMINHO}{$P$, $v$}
		\State $ultimo \gets $ PEEK-LAST($P$) \Comment{Retorna o último elemento de P sem removê-lo}
		\If{$ultimo \neq nulo$ \textbf{e} $ultimo = v$}
			\State \textbf{Retorne}
		\Else
			\State $P \gets P\ \cup $ \{$v$\}
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Perceba que, como $Q$ é uma lista cíclica, na última iteração do \textit{loop} 
da linha 6, $Q[i+1]$ será o primeiro elemento de $Q$. Assim, o menor caminho 
entre o último e o primeiro elemento de $Q$ será adicionado ao caminho final 
$P$. Isto fará com que $P$ seja um ciclo, já que ele irá começar e terminar no 
primeiro elemento de $Q$.

\section{Mutação}

Uma vez que os operadores para criação arbitrária de indivíduos estejam 
apresentados, fica faltando os operadores de mutação e recombinação para que 
se possa executar um algoritmo evolucionário completo no contexto da \ac{tmap}.
Nesta seção, por tanto, serão apresentados três operadores diferentes para 
aplicar mutação em indivíduos.

\section{Recombinação}

Por fim, será apresentado um operador para aplicar recombinação em dois 
indivíduos pais gerando dois indivíduos filhos. Esse operador é chamado de 
\textit{Simple Random Crossover}, ou Recombinação Aleatória Simples, e está 
ilustrado no pseudocódigo~\ref{recombinacao}. O operador consiste em tentar 
trocar um agente de um indivíduo por um agente do outro indivíduo selecionado 
para recombinação.

\begin{algorithm}                   % enter the algorithm environment
	\caption{\textit{Simple Random Crossover}}          % give the algorithm a caption
	\label{recombinacao}                           % and a label for \ref{} commands later in the document
	\algcomment{\begin{center} Fonte: O Autor \end{center}}
	\begin{algorithmic}[1]                   % enter the algorithmic environment
		\Procedure{SIMPLE-RANDOM-CROSSOVER}{$Solucao_{a}, Solucao_{b}, r$}
		\newline
		\Comment{Os parâmetros são dois indivíduos e $r$, o número de agentes}
		\State $r_{i} \gets $ escolhe um número aleatório entre $1\ ...\ r$
		\State $C_{a} \gets $ Cópia($Solucao_{a}$) \Comment{Este é o filho do indivíduo $a$}
		\State $C_{b} \gets $ Cópia($Solucao_{b}$) \Comment{Este é o filho do indivíduo $b$}
		\State $Agente_{a} \gets $ RETORNA-AGENTE($C_{a}$, $r_{i}$)
		\State $Agente_{b} \gets $ RETORNA-AGENTE($C_{b}$, $r_{i}$)
		\If{o centro do $Agente_{a}$ for igual ao centro do $Agente_{b}$}
			\State CONFIGURA-AGENTE($C_{a}$, $r_{i}$, $Agente_{b}$)
			\State CONFIGURA-AGENTE($C_{b}$, $r_{i}$, $Agente_{a}$)
			\State \textbf{Retorne} $C_{a}$, $C_{b}$
		\Else
			\For{$j \in 1\ ...\ r$}
				$agente \gets $ RETORNA-AGENTE($C_{b}$, $j$)
				\If{o centro do $Agente_{a}$ está no caminho do $agente$}
					\State $Agente_{b} \gets agente$
					\State CONFIGURA-AGENTE($C_{a}$, $r_{i}$, $Agente_{b}$)
					\State CONFIGURA-AGENTE($C_{b}$, $j$, $Agente_{a}$)
					\State \textbf{Retorne} $C_{a}$, $C_{b}$
				\EndIf
			\EndFor
			\State CONFIGURA-AGENTE($C_{a}$, $r_{i}$, $Agente_{b}$)
			\State CONFIGURA-AGENTE($C_{b}$, $r_{i}$, $Agente_{a}$)
			\State \textbf{Retorne} $C_{a}$, $C_{b}$
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

O operador começa escolhendo um índice, $r_{i}$ de um agente aleatoriamente. 
Depois, uma cópia dos indivíduos é atribuída a dois novos indivíduos filhos. 
A seguir, o operador verifica se os agentes no índice $r_{i}$ possuem o mesmo 
vértice como centro. Em caso positivo, o operador imediatamente troca um agente 
pelo outro entre os dois indivíduos filhos. Em caso negativo, o operador tenta 
encontrar o agente do indivíduo $b$ cujo caminho passe pelo centro do agente 
posicionado no índice $r_{i}$ do indivíduo $a$. Encontrando este agente, o 
operador faz a troca. Caso não seja encontrado nenhum agente, o operador vai 
simplesmente trocar os agentes que estão no mesmo índice, $r_{i}$, em seus 
respectivos indivíduos.